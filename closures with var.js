//39. ошибка с замыканием при асинхронности. Вывод будет неправильный, потому что через вар мы только один раз создаем переменную i и затем на каждой итерации она каждый раз перезаписывается. Замыкания в данном случае не создается и в итоге, когда выполняется таймаут (или какой-то коллбэк, если он будет), то этот таймаут будет обращаться к глобальной переменной i, которая после выполнения цикла будет равна 6. Решается проблема просто использованием let, в таком случае при каждой итерации создается свой локальный scope со своей локальной переменной i на которую и замыкается вызов setTimeout. Либо можно создать замыкание вручную.
const fib = [1, 2, 3, 5, 8, 13]

for (var i = 0; i < fib.length; i++) {
  (function(j) {
    setTimeout(function () {
      console.log(`fib[${j}] = ${fib[j]}`)
    }, 1500)
  })(i)
}

//хойстинг var
var a = 5;
function f() {
	// a == undefined
	if(a) {
		console.log(a);
		var a = 10; // var хойстится наверх в начало функции и принимает значение undefined, условие не выполняется, консоль пустая
	}
}
f()